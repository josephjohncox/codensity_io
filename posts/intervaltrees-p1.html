<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Joseph Cox">
<meta name="dcterms.date" content="2024-11-13">
<meta name="description" content="Exploring Interval Trees in Python: Deletion, Splitting, and Earliest Interval Queries">

<title>Interval Trees – Joseph John Cox</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<meta name="quarto:status" content="draft">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
<meta property="og:title" content="Interval Trees – Joseph John Cox">
<meta property="og:description" content="Exploring Interval Trees in Python: Deletion, Splitting, and Earliest Interval Queries">
<meta property="og:site_name" content="Joseph John Cox">
<meta property="og:locale" content="en_US">
<meta name="twitter:title" content="Interval Trees – Joseph John Cox">
<meta name="twitter:description" content="Exploring Interval Trees in Python: Deletion, Splitting, and Earliest Interval Queries">
<meta name="twitter:creator" content="@josephjohncox">
<meta name="twitter:card" content="summary">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top"><div id="quarto-draft-alert" class="alert alert-warning"><i class="bi bi-pencil-square"></i>Draft</div>
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Joseph John Cox</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../projects.html"> 
<span class="menu-text">Projects</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#using-an-extended-number-line" id="toc-using-an-extended-number-line" class="nav-link" data-scroll-target="#using-an-extended-number-line">Using an Extended Number Line</a></li>
  <li><a href="#the-easy-way" id="toc-the-easy-way" class="nav-link" data-scroll-target="#the-easy-way">The Easy Way</a>
  <ul class="collapse">
  <li><a href="#setting-up-an-interval-tree-in-python" id="toc-setting-up-an-interval-tree-in-python" class="nav-link" data-scroll-target="#setting-up-an-interval-tree-in-python">Setting Up an Interval Tree in Python</a>
  <ul class="collapse">
  <li><a href="#updating-stats" id="toc-updating-stats" class="nav-link" data-scroll-target="#updating-stats">Updating Stats</a></li>
  <li><a href="#getting-the-height" id="toc-getting-the-height" class="nav-link" data-scroll-target="#getting-the-height">Getting the Height</a></li>
  </ul></li>
  <li><a href="#the-interval-tree-class" id="toc-the-interval-tree-class" class="nav-link" data-scroll-target="#the-interval-tree-class">The Interval Tree Class</a></li>
  <li><a href="#invariants" id="toc-invariants" class="nav-link" data-scroll-target="#invariants">Invariants</a></li>
  <li><a href="#deletion-and-splitting-operations" id="toc-deletion-and-splitting-operations" class="nav-link" data-scroll-target="#deletion-and-splitting-operations">Deletion and Splitting Operations</a></li>
  <li><a href="#insertion" id="toc-insertion" class="nav-link" data-scroll-target="#insertion">Insertion</a></li>
  <li><a href="#mathematical-aside" id="toc-mathematical-aside" class="nav-link" data-scroll-target="#mathematical-aside">Mathematical Aside</a>
  <ul class="collapse">
  <li><a href="#meet-semilattice-structure" id="toc-meet-semilattice-structure" class="nav-link" data-scroll-target="#meet-semilattice-structure">Meet Semilattice Structure</a></li>
  <li><a href="#complemented-distributive-lattice-structure" id="toc-complemented-distributive-lattice-structure" class="nav-link" data-scroll-target="#complemented-distributive-lattice-structure">Complemented Distributive Lattice Structure</a></li>
  <li><a href="#categorical-structure" id="toc-categorical-structure" class="nav-link" data-scroll-target="#categorical-structure">Categorical Structure</a></li>
  </ul></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Interval Trees</h1>
  <div class="quarto-categories">
    <div class="quarto-category">posts</div>
    <div class="quarto-category">python</div>
    <div class="quarto-category">algorithms</div>
    <div class="quarto-category">scheduling</div>
    <div class="quarto-category">operations research</div>
    <div class="quarto-category">data structures</div>
  </div>
  </div>

<div>
  <div class="description">
    Exploring Interval Trees in Python: Deletion, Splitting, and Earliest Interval Queries
  </div>
</div>


<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Joseph Cox </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">November 13, 2024</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>Interval trees are an interesting data structure that provides efficient management and querying of intervals, which are particularly useful in scheduling, computational geometry, and time-based applications.</p>
<p>Use cases include:</p>
<ul>
<li><p>Scheduling: Finding available time slots and detecting conflicts</p></li>
<li><p>Resource Management: Tracking continuous blocks of memory or bandwidth</p></li>
<li><p>Genomics: Analyzing overlapping DNA sequences</p></li>
<li><p>Computational Geometry: Detecting line segment intersections</p></li>
<li><p>Geographic Systems: Managing map layers and spatial queries</p></li>
<li><p>Database Optimization: Indexing temporal data ranges</p></li>
<li><p>Cache Management: Optimizing memory access patterns</p></li>
</ul>
</section>
<section id="using-an-extended-number-line" class="level1">
<h1>Using an Extended Number Line</h1>
<p>For some applications, we can extend the number line to include infinite values to simplify the logic of interval tree operations. This allows us to represent intervals like (-∞, a] and [b, ∞) elegantly. Additionally, distinguishing between closed [a,b] and open (a,b) intervals, along with representing empty intervals ∅, provides mathematical rigor. However, we will focus on a simpler approach using finite, closed intervals for clarity.</p>
<p>The <a href="https://pypi.org/project/portion/">portion</a> library provides these extended interval capabilities if needed, but its additional complexity isn’t necessary for our core interval tree implementation.</p>
</section>
<section id="the-easy-way" class="level1">
<h1>The Easy Way</h1>
<p>The code for this section is available on <a href="https://github.com/josephjohncox/Tree-Mendous/tree/main/basic/avl.py">GitHub</a>.</p>
<section id="setting-up-an-interval-tree-in-python" class="level2">
<h2 class="anchored" data-anchor-id="setting-up-an-interval-tree-in-python">Setting Up an Interval Tree in Python</h2>
<p>For this tutorial, we will implement an interval tree using an AVL tree as our foundation. An AVL tree is a self-balancing binary search tree that maintains a height balance factor, ensuring O(log n) operations.</p>
<p>Let’s examine the core building block - the AVL tree node that we’ll extend to handle intervals.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> IntervalNode:</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, start: <span class="bu">float</span>, end: <span class="bu">float</span>):</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.start <span class="op">=</span> start</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.end <span class="op">=</span> end</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.length <span class="op">=</span> end <span class="op">-</span> start</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.total_length <span class="op">=</span> <span class="va">self</span>.length</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.left <span class="op">=</span> <span class="va">None</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.right <span class="op">=</span> <span class="va">None</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.height <span class="op">=</span> <span class="dv">1</span>  <span class="co"># For AVL tree balancing</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> update_stats(<span class="va">self</span>):</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">pass</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span class="at">@staticmethod</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> get_height(node: IntervalNode <span class="op">|</span> <span class="va">None</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">pass</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The structure here is similar to any standard BST node, with the addition of the <code>height</code> attribute, a cached <code>length</code> attribute, a cached <code>total_length</code> attribute, and the <code>update_stats</code> method.</p>
<p>We maintain these length attributes to have slightly faster queries of the length of the intervals in the subtree.</p>
<section id="updating-stats" class="level3">
<h3 class="anchored" data-anchor-id="updating-stats">Updating Stats</h3>
<p>The <code>update_stats</code> method is a good candidate for a lazy update, as we can traverse the tree and update the length and height attributes of the nodes as we traverse.</p>
<p>This method allows us to maintain the length and height attributes in the nodes as we insert and delete intervals, only updating the affected nodes and their ancestors as needed.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> update_stats(<span class="va">self</span>):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.length <span class="op">=</span> <span class="va">self</span>.end <span class="op">-</span> <span class="va">self</span>.start</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.total_length <span class="op">=</span> <span class="va">self</span>.length</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.left:</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.total_length <span class="op">+=</span> <span class="va">self</span>.left.total_length</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.right:</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.total_length <span class="op">+=</span> <span class="va">self</span>.right.total_length</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.height <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> <span class="bu">max</span>(<span class="va">self</span>.get_height(<span class="va">self</span>.left), <span class="va">self</span>.get_height(<span class="va">self</span>.right))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="getting-the-height" class="level3">
<h3 class="anchored" data-anchor-id="getting-the-height">Getting the Height</h3>
<p>The <code>get_height</code> method is a static accessor that returns the height of a node. It handles the base case of empty subtrees by returning 0 for <code>None</code> nodes, establishing a natural recursion.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>    <span class="at">@staticmethod</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> get_height(node: IntervalNode <span class="op">|</span> <span class="va">None</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> node.height <span class="cf">if</span> node <span class="cf">else</span> <span class="dv">0</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="the-interval-tree-class" class="level2">
<h2 class="anchored" data-anchor-id="the-interval-tree-class">The Interval Tree Class</h2>
<p>The interval tree class is a wrapper around the AVL tree node class, providing a root node and methods for inserting, deleting, and querying intervals.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> IntervalTree:</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.root <span class="op">=</span> <span class="va">None</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We will implement the insertion, deletion, and splitting operations in the next section. However, we will elide the details of the AVL tree balancing logic for now.</p>
</section>
<section id="invariants" class="level2">
<h2 class="anchored" data-anchor-id="invariants">Invariants</h2>
<p>The interval tree maintains the following invariants:</p>
<ol type="1">
<li>No two intervals in the tree overlap</li>
<li>The tree is balanced, ensuring O(log n) operations</li>
</ol>
</section>
<section id="deletion-and-splitting-operations" class="level2">
<h2 class="anchored" data-anchor-id="deletion-and-splitting-operations">Deletion and Splitting Operations</h2>
<p>The <code>_delete_overlaps</code> method is a key operation for maintaining disjoint intervals in our tree. Given an interval <code>[start, end]</code>, it removes all intervals that overlap with it, collecting them in a list for potential later use.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _delete_overlaps(<span class="va">self</span>, node: Optional[IntervalNode], start: <span class="bu">int</span>, end: <span class="bu">int</span>, </span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>                        overlapping_nodes: List[IntervalNode]) <span class="op">-&gt;</span> Optional[IntervalNode]:</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> node:</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>        <span class="co"># If the current node interval is completely after the interval to delete, go left</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> end <span class="op">&lt;=</span> node.start:</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>            node.left <span class="op">=</span> <span class="va">self</span>._delete_overlaps(node.left, start, end, overlapping_nodes)</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>        <span class="co"># If the current node interval is completely before the interval to delete, go right</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> start <span class="op">&gt;=</span> node.end:</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>            node.right <span class="op">=</span> <span class="va">self</span>._delete_overlaps(node.right, start, end, overlapping_nodes)</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Current node overlaps with [start, end], remove it and collect it</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>            overlapping_nodes.append(node)</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Delete this node and replace it with its children</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> node.left <span class="kw">and</span> node.right:</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Node with two children: Get the inorder successor (smallest in the right subtree)</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>                successor <span class="op">=</span> <span class="va">self</span>._get_min(node.right)</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Copy the successor's content to this node</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>                node.start <span class="op">=</span> successor.start</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>                node.end <span class="op">=</span> successor.end</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Delete the successor</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>                node.right <span class="op">=</span> <span class="va">self</span>._delete_overlaps(node.right, successor.start, successor.end, overlapping_nodes)</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> node.left:</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>                node <span class="op">=</span> node.left</span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>                node <span class="op">=</span> node.right</span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> node:</span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>            node.update_stats()</span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>            node <span class="op">=</span> <span class="va">self</span>._rebalance(node)</span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> node</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The deletion algorithm exploits BST properties to achieve O(log n) overlap detection. The left/right traversal pattern follows directly from the interval ordering - intervals are sorted by start time, so binary search efficiently locates overlaps. For overlapping nodes, successor replacement maintains the BST invariant by selecting min(right_subtree), preserving both the ordering property and the AVL balance. This combines interval scheduling constraints with BST deletion in a single operation.</p>
<p>This operation is key for interval scheduling - by removing overlaps during insertion, we maintain our disjoint interval invariant.</p>
<p>After deletion, we split overlapping intervals into non-overlapping fragments. For each overlapping interval <code>[a,b]</code>, we create up to two new intervals: <code>[a,start)</code> if <code>a &lt; start</code>, and <code>[end,b)</code> if <code>end &lt; b</code>. This splitting operation preserves the maximum amount of the original intervals while maintaining our disjoint invariant.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> delete_interval(<span class="va">self</span>, start: <span class="bu">int</span>, end: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Find overlapping intervals</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>        overlapping_nodes: List[IntervalNode] <span class="op">=</span> []</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.root <span class="op">=</span> <span class="va">self</span>._delete_overlaps(<span class="va">self</span>.root, start, end, overlapping_nodes)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>        <span class="co"># For each overlapping interval, we may need to split it</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> node <span class="kw">in</span> overlapping_nodes:</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> node.start <span class="op">&lt;</span> start:</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Left part remains available</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.root <span class="op">=</span> <span class="va">self</span>._insert(<span class="va">self</span>.root, IntervalNode(node.start, start))</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> node.end <span class="op">&gt;</span> end:</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Right part remains available</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.root <span class="op">=</span> <span class="va">self</span>._insert(<span class="va">self</span>.root, IntervalNode(end, node.end))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="insertion" class="level2">
<h2 class="anchored" data-anchor-id="insertion">Insertion</h2>
<p>Curiously, insertion is a simpler operation than deletion. We can insert an interval <code>[start, end]</code> by simply inserting it into the tree. If the interval overlaps with any existing intervals, the tree will automatically split them as we saw in the deletion section. This again maintains our disjoint interval invariant. And preserves the inserted interval as is.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> insert_interval(<span class="va">self</span>, start: <span class="bu">int</span>, end: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>        overlapping_nodes: List[IntervalNode] <span class="op">=</span> []</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.root <span class="op">=</span> <span class="va">self</span>._delete_overlaps(<span class="va">self</span>.root, start, end, overlapping_nodes)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Merge overlapping intervals with the new interval</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> node <span class="kw">in</span> overlapping_nodes:</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>            start <span class="op">=</span> <span class="bu">min</span>(start, node.start)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>            end <span class="op">=</span> <span class="bu">max</span>(end, node.end)</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Insert the merged interval</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.root <span class="op">=</span> <span class="va">self</span>._insert(<span class="va">self</span>.root, IntervalNode(start, end))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="mathematical-aside" class="level2">
<h2 class="anchored" data-anchor-id="mathematical-aside">Mathematical Aside</h2>
<p>Our interval tree operations can be viewed through the lens of lattice theory and order theory. The intervals form a partially ordered set (poset) with respect to the containment relation, but our operations are more interesting than simple containment.</p>
<p>Let’s consider what’s happening algebraically:</p>
<ol type="1">
<li><p><strong>Interval Splitting Operation</strong><br>
For an interval ( I = [a,b] ) and a deletion region ( D = [x,y] ), our splitting operation is effectively:</p>
<p>[ (I, D) =</p>
<span class="math display">\[\begin{cases}
\{ [a, x], [y, b] \} &amp; \text{if } a &lt; x &lt; y &lt; b \\
\{ [a, x] \} &amp; \text{if } a &lt; x &lt; b \leq y \\
\{ [y, b] \} &amp; \text{if } x \leq a &lt; y &lt; b \\
\emptyset &amp; \text{if } x \leq a \leq b \leq y \\
\{ [a, b] \} &amp; \text{if } y \leq a \text{ or } b \leq x
\end{cases}\]</span>
<p>]</p>
<p>This accounts for all possible relative positions of ( a, x, y, b ). Essentially, we remove the overlap ( I D ) from ( I ) to preserve maximal non-overlapping segments. This operation forms a meet-semilattice where the meet operation ( ) is the intersection of intervals.</p>
<p><strong>Visualization</strong></p>
<img src="intervaltrees-p1_files/mediabag/7d7988921a97361e0ef706f8b21f7ceac27cd8b3.svg" class="img-fluid"></li>
<li><p><strong>Interval Merging During Insertion</strong><br>
When inserting ( I = [a,b] ), we perform:</p>
<p>[ (I_1,,I_n,I) = [(a_1,,a_n,a), (b_1,,b_n,b)] ]</p>
<p>where ( I_1,,I_n ) are overlapping intervals. This forms a join-semilattice where the join operation ( ) creates the smallest interval containing all operands.</p>
<p><strong>Visualization of Interval Merging</strong>:</p>
<img src="intervaltrees-p1_files/mediabag/570a0a5eb9d054d60e310b04e3913d4d5bc3abe5.svg" class="img-fluid"></li>
</ol>
<p>The key mathematical insight is that our operations form a <strong>complemented distributive lattice</strong> on the space of disjoint interval sets. The complement operation corresponds to our splitting operation, while the join is our merging operation.</p>
<p>This algebraic structure ensures that:</p>
<ol type="1">
<li>Our operations are well-defined and closed.</li>
<li>The disjoint property is preserved as an invariant.</li>
<li>The operations are associative and commutative.</li>
</ol>
<p>This is why our seemingly complex tree operations reduce to clean algebraic manipulations on intervals, giving us confidence in their correctness and completeness.</p>
<section id="meet-semilattice-structure" class="level3">
<h3 class="anchored" data-anchor-id="meet-semilattice-structure">Meet Semilattice Structure</h3>
<p>The meet operation on intervals has interesting algebraic properties. For any two intervals ( I_1 = [a_1,b_1] ) and ( I_2 = [a_2,b_2] ), their meet is:</p>
[ I_1 I_2 =
<span class="math display">\[\begin{cases}
[\max(a_1,a_2), \min(b_1,b_2)] &amp; \text{if } \max(a_1,a_2) \leq \min(b_1,b_2) \\
\emptyset &amp; \text{otherwise}
\end{cases}\]</span>
<p>]</p>
<p>This operation satisfies the semilattice axioms:</p>
<ol type="1">
<li><strong>Idempotency</strong>: ( I I = I )</li>
<li><strong>Commutativity</strong>: ( I_1 I_2 = I_2 I_1 )</li>
<li><strong>Associativity</strong>: ( (I_1 I_2) I_3 = I_1 (I_2 I_3) )</li>
</ol>
<p>The empty interval ( ) acts as a bottom element: ( I = ) for all intervals ( I ).</p>
<p><strong>Lattice Diagram of Meet Operation</strong>:</p>
<img src="intervaltrees-p1_files/mediabag/c4e17a24ef42ac5c1fc825a5616c24e6b454f221.svg" class="img-fluid">
<p>This diagram represents the lattice structure where ( I_1 ) and ( I_2 ) converge to their meet ( I_1 I_2 ), and ( ) is the bottom element.</p>
<p>In our interval tree, this structure manifests when we split intervals during deletion. The splitting operation can be viewed as computing the meet of an interval with the complement of the deletion region, followed by considering connected components:</p>
<p>[ (I,D) = ( I ) ]</p>
<p>This algebraic view explains why our splitting operation preserves the maximum possible portions of the original intervals while maintaining disjointness.</p>
</section>
<section id="complemented-distributive-lattice-structure" class="level3">
<h3 class="anchored" data-anchor-id="complemented-distributive-lattice-structure">Complemented Distributive Lattice Structure</h3>
<p>Our interval operations form a complemented distributive lattice ( (L, , , , , ) ) where:</p>
<ol type="1">
<li><p><strong>Join Operation</strong> (( )): For overlapping intervals, creates their union:</p>
<p>[ I_1 I_2 = [(a_1,a_2), (b_1,b_2)] ]</p></li>
<li><p><strong>Meet Operation</strong> (( )): Creates their intersection:</p>
<p>[ I_1 I_2 = [(a_1,a_2), (b_1,b_2)] ]</p></li>
<li><p><strong>Complement</strong> (( )): For an interval ( I = [a,b] ):</p>
<p>[ = (-,a) (b,) ]</p></li>
</ol>
<p>The lattice satisfies these key properties:</p>
<ol type="1">
<li><p><strong>Distributivity</strong>: For all intervals ( I_1, I_2, I_3 ):</p>
<p>[ I_1 (I_2 I_3) = (I_1 I_2) (I_1 I_3) ] [ I_1 (I_2 I_3) = (I_1 I_2) (I_1 I_3) ]</p></li>
<li><p><strong>Complement Laws</strong>: For any interval ( I ):</p>
<p>[ I = ] [ I = ]</p></li>
<li><p><strong>Bounds</strong>: ( ) is the bottom element and ( ) is the top element:</p>
<p>[ I I ]</p></li>
</ol>
<p><strong>Hasse Diagram of Lattice Structure</strong>:</p>
<img src="intervaltrees-p1_files/mediabag/2f6f72a856e8a2ece786fd9b714571c705c80674.svg" class="img-fluid">
<p>This structure explains why our interval operations are well-behaved:</p>
<ol type="1">
<li>The distributive property ensures our splitting and merging operations are consistent.</li>
<li>The complement operation gives us a natural way to handle deletion.</li>
<li>The lattice bounds provide natural edge cases for our algorithms.</li>
</ol>
<p>In our implementation, we restrict ourselves to finite intervals for practicality, but the algebraic structure remains the same. The tree operations preserve these lattice properties while providing efficient access to the intervals.</p>
</section>
<section id="categorical-structure" class="level3">
<h3 class="anchored" data-anchor-id="categorical-structure">Categorical Structure</h3>
<p>Our interval operations can be elegantly expressed in category theory, revealing deeper connections to other mathematical structures.</p>
<section id="the-category-of-intervals" class="level4">
<h4 class="anchored" data-anchor-id="the-category-of-intervals">The Category of Intervals</h4>
<p>To illustrate the categorical structure, consider the following diagram of intervals and inclusion morphisms:</p>
<img src="intervaltrees-p1_files/mediabag/ed25e61224b88b34be0cd16799c93315ea68cf3a.svg" class="img-fluid">
<p>In this diagram:</p>
<ul>
<li>( f: I_1 I_2 ) is a morphism when ( I_1 I_2 ).</li>
<li>( I_1 I_2 ) is the intersection of ( I_1 ) and ( I_2 ), with inclusion morphisms ( g ) and ( h ).</li>
</ul>
<p>Let’s define <strong>Intv</strong>, the category of intervals where:</p>
<ol type="1">
<li><strong>Objects</strong> are intervals ( [a,b] ) where ( a,b {} ).</li>
<li><strong>Morphisms</strong> ( f: I_1 I_2 ) are inclusion maps where ( I_1 I_2 ).</li>
<li><strong>Identity</strong> morphisms are the natural inclusions ( _I: I I ).</li>
<li><strong>Composition</strong> is the usual composition of inclusions.</li>
</ol>
<p>This category has interesting properties:</p>
<ol type="1">
<li><strong>Initial Object</strong>: ( ) (empty interval).</li>
<li><strong>Terminal Object</strong>: ( ) (full real line).</li>
<li><strong>Products</strong>: The meet operation ( ) gives categorical products.</li>
<li><strong>Coproducts</strong>: The join operation ( ) gives categorical coproducts.</li>
</ol>
</section>
<section id="functor-to-sets" class="level4">
<h4 class="anchored" data-anchor-id="functor-to-sets">Functor to Sets</h4>
<p>There’s a natural functor <span class="math inline">\(F: \text{Intv} \to \text{Set}\)</span> where:</p>
<p><span class="math inline">\(F([a,b]) = \{ x \in \mathbb{R} \mid a \leq x \leq b \}\)</span></p>
<p>This functor preserves the lattice structure and shows how our interval operations relate to set operations.</p>
<p>To visualize the functor ( F: ), consider mapping intervals to their corresponding subsets on the real line:</p>
<img src="intervaltrees-p1_files/mediabag/eca3e897a1e9f9885fb1865a377520ad3d132efc.svg" class="img-fluid">
</section>
<section id="monoidal-structure" class="level4">
<h4 class="anchored" data-anchor-id="monoidal-structure">Monoidal Structure</h4>
<p>Our interval operations form a symmetric monoidal category with:</p>
<ol type="1">
<li><strong>Tensor Product</strong>: ( I_1 I_2 = I_1 I_2 ) (intersection).</li>
<li><strong>Unit Object</strong>: ( ) (full real line).</li>
</ol>
<p>The coherence conditions are satisfied by the natural associativity and commutativity of interval intersection.</p>
</section>
<section id="galois-connection" class="level4">
<h4 class="anchored" data-anchor-id="galois-connection">Galois Connection</h4>
<p>The splitting and merging operations form a Galois connection between the lattice of intervals and the lattice of sets of intervals. Specifically, the splitting operation ( : L P(L) ) and the merging operation ( : P(L) L ) are adjoint functors satisfying:</p>
<p>[ (I) S I (S) ]</p>
<p>for an interval ( I ) and a set of intervals ( S ). This adjunction reflects the duality between partitioning an interval into non-overlapping pieces and combining overlapping intervals into a single interval.</p>
</section>
<section id="sheaf-structure" class="level4">
<h4 class="anchored" data-anchor-id="sheaf-structure">Sheaf Structure</h4>
<p>The collection of intervals forms a sheaf on ( ) where:</p>
<ol type="1">
<li><strong>Sections</strong> over an open set ( U ) are the intervals contained in ( U ).</li>
<li><strong>Restriction Maps</strong> are the natural inclusions.</li>
<li><strong>Gluing</strong> corresponds to our merge operation.</li>
</ol>
<p>The sheaf properties ensure our local operations (on individual intervals) coherently extend to global operations (on sets of intervals).</p>
<p>This categorical perspective reveals that our interval tree isn’t just a data structure—it’s implementing fundamental mathematical structures that appear across mathematics. The categorical properties ensure our operations are “natural” in a precise mathematical sense.</p>
<p>The sheaf structure can be visualized with open sets and sections:</p>
<img src="intervaltrees-p1_files/mediabag/757e82adf68c61f3acd7d566dddd55e192ef5ff9.svg" class="img-fluid">
<p>In this diagram:</p>
<ul>
<li>( s_1 ) and ( s_2 ) are sections over ( U_1 ) and ( U_2 ).</li>
<li>The restriction maps ( ) connect these sections to their agreement on the overlap ( U_1 U_2 ).</li>
<li>The gluing axiom allows us to form a global section ( s ) over ( U_1 U_2 ).</li>
</ul>
</section>
<section id="sheaf-structure-and-its-connection-to-logic-and-toposes" class="level4">
<h4 class="anchored" data-anchor-id="sheaf-structure-and-its-connection-to-logic-and-toposes">Sheaf Structure and Its Connection to Logic and Toposes</h4>
<p>The collection of intervals naturally forms a <strong>sheaf</strong> over the real line ( ). In topology and algebraic geometry, a sheaf formalizes the idea of data that varies continuously over a space, capturing both local and global properties.</p>
<p><strong>Sheaf Definition in This Context:</strong></p>
<ol type="1">
<li><strong>Open Covering:</strong> Consider an open cover ( {U_i} ) of ( ).</li>
<li><strong>Sections:</strong> Over each open set ( U_i ), the sections are the intervals entirely contained within ( U_i ).</li>
<li><strong>Restriction Maps:</strong> For open sets ( V U ), the restriction map ( _{UV} ) takes an interval in ( U ) to itself viewed in ( V ) (since intervals are subsets of ( )).</li>
<li><strong>Gluing Axiom:</strong> If we have sections over each ( U_i ) that agree on overlaps ( U_i U_j ), they can be uniquely glued together to form a global section over ( U_i ).</li>
</ol>
<p><strong>Connection to Logic and Toposes:</strong></p>
<p>A <strong>topos</strong> can be thought of as a generalized space that behaves like the category of sets but has a rich internal logic. In particular, toposes provide a framework where we can perform logical reasoning in a geometric context.</p>
<p>Our sheaf of intervals over ( ) can be seen as a <strong>local home for logical assertions</strong> about intervals. The intervals represent predicates about positions on the real line (e.g., “the value lies between ( a ) and ( b )”). The operations on intervals correspond to logical connectives:</p>
<ul>
<li><strong>Intersection (( ))</strong>: Logical conjunction (“and”).</li>
<li><strong>Union (( ))</strong>: Logical disjunction (“or”).</li>
<li><strong>Complement (( ))</strong>: Logical negation.</li>
</ul>
<p>In the language of topos theory:</p>
<ol type="1">
<li><strong>Subobject Classifier:</strong> Intervals can be seen as subobjects of ( ), and the structure of intervals aligns with the subobject classifier in a topos.</li>
<li><strong>Internal Logic:</strong> The interval operations form a Heyting algebra, particularly when considering open intervals and the intuitionistic logic inherent in topos theory. This aligns with the internal logic of a topos, which does not presume the law of excluded middle.</li>
<li><strong>Grothendieck Topology:</strong> The open sets of ( ) form a basis for a Grothendieck topology, over which our sheaf of intervals is defined.</li>
</ol>
<p><strong>Implications for Our Interval Tree:</strong></p>
<ul>
<li><strong>Local to Global Principle:</strong> The interval tree manages local intervals (sections) efficiently while the sheaf structure ensures these local pieces fit together into a coherent global structure.</li>
<li><strong>Logical Reasoning:</strong> Operations on the interval tree correspond to logical deductions. For instance, querying the tree for overlaps is akin to evaluating logical predicates.</li>
<li><strong>Topos-Theoretic Interpretation:</strong> The interval tree embodies a topos-theoretic structure where computations on intervals reflect computations in the internal logic of the topos.</li>
</ul>
<p><strong>Why This Matters:</strong></p>
<p>Understanding the sheaf and topos structure provides deeper insights:</p>
<ul>
<li><strong>Modularity:</strong> Sheaf properties ensure we can modify intervals locally without unintended global side effects.</li>
<li><strong>Consistency:</strong> The logical framework guarantees that our operations are consistent and free from contradictions.</li>
<li><strong>Extensibility:</strong> The categorical perspective allows us to generalize interval trees to more complex spaces and data types, benefiting from the rich theory of toposes.</li>
</ul>
<p>In essence, the interval tree isn’t just a practical data structure—it’s a concrete manifestation of abstract mathematical concepts from topology, logic, and category theory. This duality enriches our understanding and opens doors to advanced applications in computer science and mathematics.</p>


</section>
</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/codensity\.io");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://giscus.app/client.js" data-repo="josephjohncox/blogComments" data-repo-id="R_kgDONO81dA" data-category="Announcements" data-category-id="DIC_kwDONO81dM4CkPns" data-mapping="title" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="en" crossorigin="anonymous" async="">
</script>
<input type="hidden" id="giscus-base-theme" value="light">
<input type="hidden" id="giscus-alt-theme" value="light">
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>© Copyright 2024 Joseph John Cox. Except where otherwise noted, all text and images licensed CC-BY-NC 4.0.</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>